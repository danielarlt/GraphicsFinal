<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Daniel Arlt</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

    <script>
        let canvas = document.getElementById("renderCanvas"); // Get the canvas element
        let engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        /******* Add the create scene function ******/
        var createScene = function () {
            let gun, ground, viewModel, blueMat, grid, gunMat, target, targetMat, target2Mat, ray;

            var scene = new BABYLON.Scene(engine);
            scene.collisionsEnabled = true;
            scene.gravity = new BABYLON.Vector3(0, -0.3, 0);
            function setupScene() {
            }

            var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 7, -50), scene);
            //camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 2, 2, new BABYLON.Vector3(0,20,0), scene);

            // Allow control of camera with WASD
            camera.keysDown.push(83);
            camera.keysUp.push(87);
            camera.keysLeft.push(65);
            camera.keysRight.push(68);

            camera._needMoveForGravity = true;

            camera.speed = 0.5;
            camera.fov = 1.25;
            camera.applyGravity = true;
            camera.ellipsoid = new BABYLON.Vector3(0.5, 1.5, 0.5);
            camera.checkCollisions = true;
            camera.attachControl(canvas, true);
            camera.inputs.remove(camera.inputs.attached.mouse);
            function setupCamera() {
            }

            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
            function setupLights() {
            }

            function setupMaterials() {
                blueMat = new BABYLON.StandardMaterial("blueMat", scene);
                blueMat.diffuseColor = new BABYLON.Color3(0, 1, 1);
                blueMat.specularColor = new BABYLON.Color3(1, 1, 1);
                grid = new BABYLON.StandardMaterial("grid", scene);
                grid.diffuseTexture = new BABYLON.Texture("Texture/grid1.png", scene);
                grid.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                gunMat = new BABYLON.StandardMaterial("gunMat", scene);
                gunMat.diffuseTexture = new BABYLON.Texture("Gun/blend/textures/handgun_C.jpg", scene);
                gunMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                targetMat = new BABYLON.StandardMaterial("targetMat", scene);
                targetMat.diffuseTexture = new BABYLON.Texture("Texture/Target.png", scene);
                targetMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                target2Mat = new BABYLON.StandardMaterial("targetMat", scene);
                target2Mat.diffuseTexture = new BABYLON.Texture("Texture/Target2.png", scene);
                target2Mat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            }

            function setupWater() {
                water = BABYLON.Mesh.CreateGroundFromHeightMap("water", "HeightMap/watermap.jpg", 500, 100, 512, 0, 0.5, scene, false);
                water.material = blueMat;
                water.position.y = 0;
                water.visibility = 0.5;
            }

            function setupGround() {
                BABYLON.SceneLoader.ImportMesh(null, "./", "HeightMap/heightMap2.babylon", scene, function (meshes, particleSystems, skeletons) {
                    ground = meshes[0];
                    ground.scaling = new BABYLON.Vector3(50, 15, 50);
                    ground.checkCollisions = true;
                    ground.position.y = 2;
                    ground.material = grid;
                })
            }

            var smokeSystem = new BABYLON.ParticleSystem("smoke", 100, scene);
            var sparkSystem = new BABYLON.ParticleSystem("spark", 1000, scene);
            var hitSystem = new BABYLON.ParticleSystem("hit", 1000, scene);

            BABYLON.SceneLoader.ImportMesh(null, "./", "Gun/Blend/Handgun_Packed3.babylon", scene, function (meshes, particleSystems, skeletons) {
                gun = meshes[0];
                //gun.position = new BABYLON.Vector3(1.2, 4.25, 52);
                gun.rotation.y = -Math.PI/2;
                gun.material = gunMat;
                gun.setParent(camera);
                gun.isPickable = false;

                smokeSystem.emitter = gun;
                sparkSystem.emitter = gun;
            })
            function setupViewModel() {
            }

            function setupSprites() {
                var spriteManagerTrees = new BABYLON.SpriteManager("treesManager", "Sprites/tree.png", 100, {width: 1787, height: 2260}, scene);
                for (let step = -225; step < 226; step += 25) {
                    var tree1 = setupTree(spriteManagerTrees, new BABYLON.Vector3(step, 9.6, -28), 17)
                    var tree2 = setupTree(spriteManagerTrees, new BABYLON.Vector3(step, 9.6, 28), 17)
                }
            }

            function setupTree(spriteManagerTrees, position, size) {
                var tree = new BABYLON.Sprite("sprite", spriteManagerTrees);
                tree.position = position;
                tree.size = size;
            }

            function setupTarget(position, rotx, roty) {
                target = new BABYLON.MeshBuilder.CreateCylinder("target", {diameter: 2, subdivisions: 32, height: 0.2}, scene);
                target.position = position;
                target.rotation.x = rotx;
                target.rotation.y = roty;
                target.uniqueId = 1;
                target.material = targetMat;
                return target;
            }

            function setupParticles() {
                // Smoke
                smokeSystem.particleTexture = new BABYLON.Texture("Particles/smoke.png", scene);
                smokeSystem.targetStopDuration = 0.05;
                smokeSystem.isLocal = true;

                smokeSystem.minEmitBox = new BABYLON.Vector3(1.4, .7, 0);
                smokeSystem.maxEmitBox = new BABYLON.Vector3(1.4, .7, 0);

                smokeSystem.colorDead = new BABYLON.Color4(1, 1, 1, 0)

                smokeSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;

                smokeSystem.emitRate = 100;

                smokeSystem.minSize = 0.1;
                smokeSystem.maxSize = 0.2;

                smokeSystem.addSizeGradient(0, 0.25);
                smokeSystem.addSizeGradient(0.25, 0.5);

                smokeSystem.minLifeTime = 0.3;
                smokeSystem.maxLifeTime = 0.4;

                smokeSystem.minAngularSpeed = -Math.PI;
                smokeSystem.maxAngularSpeed = Math.PI;

                smokeSystem.minEmitPower = 0.5;
                smokeSystem.maxEmitPower = 2;
                smokeSystem.updateSpeed = 0.0075;

                // Spark
                sparkSystem.particleTexture = new BABYLON.Texture("Particles/spark.png", scene);
                sparkSystem.targetStopDuration = 0.02;
                sparkSystem.isLocal = true;

                sparkSystem.minEmitBox = new BABYLON.Vector3(1.4, .7, 0);
                sparkSystem.maxEmitBox = new BABYLON.Vector3(1.4, .7, 0);

                sparkSystem.colorDead = new BABYLON.Color4(1, 1, 1, 0)

                sparkSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;

                sparkSystem.emitRate = 50;

                sparkSystem.minSize = 0.1;
                sparkSystem.maxSize = 0.2;

                sparkSystem.addSizeGradient(0.1, 0.2);
                sparkSystem.addSizeGradient(0.2, 0.3);

                sparkSystem.minLifeTime = 0.9;
                sparkSystem.maxLifeTime = 1;

                sparkSystem.minAngularSpeed = -Math.PI;
                sparkSystem.maxAngularSpeed = Math.PI;

                sparkSystem.direction1 = new BABYLON.Vector3(1, -0.4, -0.4);
                sparkSystem.direction2 = new BABYLON.Vector3(1, 0.4, 0.4);

                sparkSystem.minEmitPower = 0.5;
                sparkSystem.maxEmitPower = 0.5;
                sparkSystem.updateSpeed = 0.075;

                // Hit
                hitSystem.particleTexture = new BABYLON.Texture("Particles/spark.png", scene);
                hitSystem.targetStopDuration = 0.05;
                hitSystem.isLocal = true;

                hitSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0);
                hitSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0);

                hitSystem.colorDead = new BABYLON.Color4(1, 1, 1, 0)

                hitSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_STANDARD;

                hitSystem.emitRate = 50;

                hitSystem.minSize = 0.1;
                hitSystem.maxSize = 0.2;

                hitSystem.addSizeGradient(0.1, 0.2);
                hitSystem.addSizeGradient(0.2, 0.3);

                hitSystem.minLifeTime = 0.4;
                hitSystem.maxLifeTime = 0.5;

                hitSystem.minAngularSpeed = -Math.PI;
                hitSystem.maxAngularSpeed = Math.PI;

                hitSystem.minEmitPower = 0.5;
                hitSystem.maxEmitPower = 0.5;
                hitSystem.updateSpeed = 0.01;

            }

            function setupSkybox() {
                var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:1000.0}, scene);
                var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
                skyboxMaterial.backFaceCulling = false;
                skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("Skybox/Skybox", scene, ["_px.png", "_py.png", "_pz.png", "_nx.png", "_ny.png", "_nz.png"]);
                skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
                skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
                skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                skybox.material = skyboxMaterial;
            }

            function setupOrientationLines() {
                let xLine = BABYLON.MeshBuilder.CreateLines("xLine", {
                    points: [ new BABYLON.Vector3(0, 0.01, 0), new BABYLON.Vector3(4, 0.01, 0) ],
                    colors: [new BABYLON.Color4(1, 0, 0, 1), new BABYLON.Color4(1, 0, 0, 1)]
                }, scene);
                let yLine = BABYLON.MeshBuilder.CreateLines("yLine", {
                    points: [ new BABYLON.Vector3(0, 0.01, 0), new BABYLON.Vector3(0, 4.01, 0) ],
                    colors: [new BABYLON.Color4(0, 1, 0, 1), new BABYLON.Color4(0, 1, 0, 1)]
                }, scene);
                let zLine = BABYLON.MeshBuilder.CreateLines("zLine", {
                    points: [ new BABYLON.Vector3(0, 0.01, 0), new BABYLON.Vector3(0, 0.01, 4) ],
                    colors: [new BABYLON.Color4(0, 0, 1, 1), new BABYLON.Color4(0, 0, 1, 1)]
                }, scene);
            }

            // Render functions
            setupScene();
            setupCamera();
            setupLights();
            setupMaterials();
            setupWater();
            setupGround();
            test = setupTarget(new BABYLON.Vector3(0, 4, -40), Math.PI/2, 0);
            test2 = setupTarget(new BABYLON.Vector3(0, 10, -40), Math.PI/2, Math.PI/4);
            setupViewModel();
            setupSprites();
            setupParticles();
            //setupSkybox();
            //setupOrientationLines();


            function shoot() {
                var animation = new BABYLON.Animation("shoot", "rotation.z", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
                var keys = [
                    {
                        frame: 0,
                        value: 0
                    },
                    {
                        frame: 2,
                        value: Math.PI/12
                    },
                    {
                        frame: 10,
                        value: 0
                    }
                ];
                //gun.rotate(BABYLON.Axis.Z, Math.PI/12);
                animation.setKeys(keys);
                var easingFunction = new BABYLON.SineEase();
                easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEOUT);
                animation.setEasingFunction(easingFunction);
                gun.animations.push(animation);

                gunshot.play();
                // Sparks only work some of the time. idk why.
                sparkSystem.start();
                setTimeout(() => {  smokeSystem.start(); }, 200);
                scene.beginAnimation(gun, 0, 10, false, 2);
            }

            var gunshot = new BABYLON.Sound("Gunshot", "Sounds/pistol_fire2.mp3", scene, null, {
                volume: 0.5
            });

            scene.registerBeforeRender(function() {
                ray = camera.getForwardRay();

                // Handle "floating" in water by inverting gravity
                if (camera.position.y < 2) {
                    scene.gravity = new BABYLON.Vector3(0, 0.05, 0);
                }
                else if (camera.position.y > 4) {
                    scene.gravity = new BABYLON.Vector3(0, -0.3, 0);
                }
            });

            // Used for stopping holding left mouse from triggering multiple animations
            var lPointerDown = false;
            scene.onPointerObservable.add((pointerInfo) => {
                // pointerInfo.event.button == 2  RIGHT mouse button
                if (pointerInfo.event.buttons & 2) {
                    // Aim-in while holding right click
                    camera.fov = 1;
                    gun.position = new BABYLON.Vector3(0, -0.75, 1.5);

                } else if ((pointerInfo.event.buttons & 2) === 0) {
                    // Revert back to original view on release
                    camera.fov = 1.25;
                    gun.position = new BABYLON.Vector3(1.2, -1.5, 2.2);

                }

                // pointerInfo.event.button == 0  LEFT mouse button
                if (pointerInfo.event.buttons & 1) {
                    if (!lPointerDown) {
                        // Shoot gun with left click
                        shoot();
                        pickedResult = scene.pickWithRay(ray);
                        if (pickedResult.hit) {
                            hitSystem.direction1 = new BABYLON.Vector3(-ray.direction.x - 0.4, -ray.direction.y - 0.4, -ray.direction.z - 0.4);
                            hitSystem.direction2 = new BABYLON.Vector3(-ray.direction.x + 0.4, -ray.direction.y + 0.4, -ray.direction.z + 0.4);
                            hitSystem.emitter = pickedResult.pickedPoint;
                            hitSystem.start();
                            var mesh = pickedResult.pickedMesh;
                            if (mesh.uniqueId == 1) {
                                mesh.position.y += 0.1;
                                mesh.material = target2Mat;
                            }
                        }
                    }
                    lPointerDown = true;
                }
                else {
                    lPointerDown = false;
                }
            });

            return scene;
        }
        /******* End of the create scene function ******/

        let scene = createScene(); //Call the createScene function

        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });

        let oldTime = 0;
        function jump() {
            camera = scene.cameras[0];
    		var animation = new BABYLON.Animation("jump", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
    		var keys = [
    			{
    				frame: 0,
    				value: camera.position.y
    			},
    			{
    				frame: 30,
    				value: camera.position.y + 4
    			}
    		];
    		animation.setKeys(keys);

    		var easingFunction = new BABYLON.SineEase();
    		easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEOUT);
    		animation.setEasingFunction(easingFunction);

    		camera.animations.push(animation);

            // This section restricts infinite jumping
            var today = new Date();
            if (Math.floor(today.getTime()/100) - oldTime > 7) {
                scene.beginAnimation(camera, 0, 30, false, 2);
                oldTime = Math.floor(today.getTime()/100)
            }
    	}

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });

        // canvas pointer lock
        canvas.addEventListener('click', function (event) {
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
            if (canvas.requestPointerLock) canvas.requestPointerLock();
        });

        document.addEventListener("keydown", function (e) {
            // console.log(e.keyCode);
            if (e.keyCode == 27) {
                document.exitPointerLock();
            }
            else if (e.keyCode == 32) {
                jump();
            }
            else if (e.keyCode == 16) {
                scene.cameras[0].speed = 0.8;
            }
            else {
                scene.cameras[0].speed = 0.5;
            }
        });

        // mouse move when pointer is locked
    	document.addEventListener('mousemove', function(event) {
            if(document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {

                var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                // apply rotation to active camera
                scene.activeCamera.rotation.y += movementX * 0.002;
                scene.activeCamera.rotation.x += movementY * 0.002;
                scene.activeCamera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, scene.activeCamera.rotation.x));
            }
        }, false);

    </script>

   </body>

</html>
